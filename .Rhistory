n <- 4
Network <- seq(0,2.5,length.out = 4)
Response <-  seq(0,10, length.out = 4)
grid <- expand.grid(Network=Network,Response=Response)
Profit <- matrix(NA,nrow=n, ncol=n)
test <- apply(X = grid, MARGIN = 1, FUN = function(var){
print(row)
x$Tau <- 100
x$rho <- var$Network
x$omega <- var$Response
l <- playCsrBayesGame(x, learn=FALSE, verbose=FALSE)
return(sum(l$Pi$Pi1[-1]))
})
setwd('C:\\Users\\sdowning\\Google Drive\\PhD\\Dissertation\\5. platform differentiation\\csr_bayes_game')
source(file.path(getwd(),'R','csr_bayes_game_functions.R'))
##  RUN MAIN GAME SIMULATION
##  USING GAME SETUP LIST X
x <- list(
v1= 1
, v2=1
, db1=.5  # 30% buy all (y/pk) goods from current platform 1; 70% defect to multihome buying s1*(y/p1) from Plat 1, s2*(y/p2) from Plat 2
, db2=.5  # 30% buy all (y/pk) goods from current platform 2; 70% defect to multihome buying s1*(y/p1) from Plat 1, s2*(y/p2) from Plat 2
, dj1=.1
, dj2=.1
, c1=.5       ## seller MARGINAL cost
, c2=.5       ## seller MARGINAL cost
, gamma1=.05  ## seller CSR cost
, gamma2=.05  ## seller CSR cost
, w1=.02      ## Platform operator MARGINAL cost
, w2=.02      ## Platform operator MARGINAL cost
, psi1=.03    ## Platform operator CSR cost   moved --> function of (gamma, B, y, p1)
, psi2=.03    ## Platform operator CSR cost   moved --> function of (gamma, B, y, p1)
, a1=1
, a2=1
, r1=.1
, r2=.1
, omega=1.5
, rho=.8
, growth=.01
, Y=1000
, ep=1e-1
, N0=500
, Tau=150
, probs=c(.005,.025,.5,.975,.995)
, learningThreshold=.05
, n.iter=1000
, downweight=TRUE
, q=.4
, sig1.fixed=NA
, sig2.fixed=NA
, t1.change=NA
, t2.change=NA
)
n <- 4
Network <- seq(0,2.5,length.out = 4)
Response <-  seq(0,10, length.out = 4)
grid <- expand.grid(Network=Network,Response=Response)
Profit <- matrix(NA,nrow=n, ncol=n)
test <- apply(X = grid, MARGIN = 1, FUN = function(var){
print(row)
x$Tau <- 100
x$rho <- var$Network
x$omega <- var$Response
l <- playCsrBayesGame(x, learn=FALSE, verbose=FALSE)
return(sum(l$Pi$Pi1[-1]))
})
test <- apply(X = grid, MARGIN = 1, FUN = function(row){
print(row)
x$Tau <- 100
x$rho <- row$Network
x$omega <- row$Response
l <- playCsrBayesGame(x, learn=FALSE, verbose=FALSE)
return(sum(l$Pi$Pi1[-1]))
})
n <- 4
Network <- seq(0,2.5,length.out = 4)
Response <-  seq(0,10, length.out = 4)
grid <- expand.grid(Network=Network,Response=Response)
Profit <- matrix(NA,nrow=n, ncol=n)
test <- apply(X = grid, MARGIN = 1, FUN = function(row){
print(row)
x$Tau <- 100
x$rho <- row['Network']
x$omega <- row['Response']
l <- playCsrBayesGame(x, learn=FALSE, verbose=FALSE)
return(sum(l$Pi$Pi1[-1]))
})
n <- 4
Network <- seq(0,2.5,length.out = 4)
Response <-  seq(0,10, length.out = 4)
grid <- expand.grid(Network=Network,Response=Response)
Profit <- matrix(NA,nrow=n, ncol=n)
z.vec <- apply(X = grid, MARGIN = 1, FUN = function(row){
print(row)
x$Tau <- 100
x$rho <- row['Network']
x$omega <- row['Response']
l <- playCsrBayesGame(x, learn=FALSE, verbose=FALSE)
return(sum(l$Pi$Pi1[-1]))
})
Profit <- as.matrix(z.vec)
Profit
grid
matrix(z.vec,nrow=n)
matrix(z.vec,nrow=n,byrow = T)
matrix(z.vec,nrow=n,byrow = F)
n <- 4
q <- seq(0,1,length.out = 4)
Response <-  seq(0,10, length.out = 4)
grid <- expand.grid(q=q,Response=Response)
x$Tau <- 100
z.vec <- apply(X = grid, MARGIN = 1, FUN = function(row){
print(row)
x$q <- row['q']
x$omega <- row['Response']
l <- playCsrBayesGame(x, learn=FALSE, verbose=FALSE)
return(sum(l$Pi$Pi1[-1]))
})
Profit <- matrix(z.vec, nrow = n, byrow=FALSE)
image(q, Response, Profit,
xlab='q', ylab='Response')
box()
box()
Profit
x
grid
x <- list(
v1= 1
, v2=1
, db1=.5  # 30% buy all (y/pk) goods from current platform 1; 70% defect to multihome buying s1*(y/p1) from Plat 1, s2*(y/p2) from Plat 2
, db2=.5  # 30% buy all (y/pk) goods from current platform 2; 70% defect to multihome buying s1*(y/p1) from Plat 1, s2*(y/p2) from Plat 2
, dj1=.1
, dj2=.1
, c1=.5       ## seller MARGINAL cost
, c2=.5       ## seller MARGINAL cost
, gamma1=.05  ## seller CSR cost
, gamma2=.05  ## seller CSR cost
, w1=.02      ## Platform operator MARGINAL cost
, w2=.02      ## Platform operator MARGINAL cost
, psi1=.03    ## Platform operator CSR cost   moved --> function of (gamma, B, y, p1)
, psi2=.03    ## Platform operator CSR cost   moved --> function of (gamma, B, y, p1)
, a1=1
, a2=1
, r1=.1
, r2=.1
, omega=1.5
, rho=.8
, growth=.01
, Y=1000
, ep=1e-1
, N0=500
, Tau=150
, probs=c(.005,.025,.5,.975,.995)
, learningThreshold=.05
, n.iter=1000
, downweight=TRUE
, q=.4
, sig1.fixed=NA
, sig2.fixed=NA
, t1.change=NA
, t2.change=NA
)
n <- 4
psi <- seq(0,1,length.out = 4)
Response <-  seq(0,10, length.out = 4)
grid <- expand.grid(psi=psi,Response=Response)
x$Tau <- 100
z.vec <- apply(X = grid, MARGIN = 1, FUN = function(row){
print(row)
x$psi1 <- row['psi']
x$omega <- row['Response']
l <- playCsrBayesGame(x, learn=FALSE, verbose=FALSE)
return(sum(l$Pi$Pi1[-1]))
})
Profit <- matrix(z.vec, nrow = n, byrow=FALSE)
image(psi, Response, Profit,
xlab='q', ylab='Response')
box()
image(psi, Response, Profit,
xlab='psi', ylab='Response')
box()
image(psi, Response, Profit,
xlab='psi', ylab='Response');colorbar()
image(psi, Response, Profit,
xlab='psi', ylab='Response');colorbar.plot()
install.packages('fields')
library(fields)
image(psi, Response, Profit,
xlab='psi', ylab='Response')
colorbar()
box()
colorbar.plot()
colorbar.plot(strip = z.vec)
colorbar.plot(psi,Response,strip = z.vec)
image(psi, Response, Profit,
xlab='psi', ylab='Response')
colorbar.plot(psi,Response,strip = z.vec)
library(fields)
data("volcano")
volcano
dim(volcano)
image.plot(psi, Response, Profit,
xlab='psi', ylab='Response')
contour(Profit, add=TRUE)
box()
image.plot(psi, Response, Profit,
xlab='psi', ylab='Response')
contour(Profit, add=TRUE)
n <- 4
x$Tau <- 100
y1 <- seq(.45,.6,length.out = 4)
y2 <-  seq(0,10, length.out = 4)
grid <- expand.grid(y1=y1,y2=y2)
z.vec <- apply(X = grid, MARGIN = 1, FUN = function(row){
print(row)
x$c1 <- row['y1']
x$omega <- row['y2']
l <- playCsrBayesGame(x, learn=FALSE, verbose=FALSE)
return(sum(l$Pi$Pi1[-1]))
})
Profit <- matrix(z.vec, nrow = n, byrow=FALSE)
image.plot(y1, y2, Profit,
xlab='c1', ylab='Response')
contour(Profit, add=TRUE)
box()
z.vec
